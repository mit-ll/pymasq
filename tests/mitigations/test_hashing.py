#!/usr/bin/env python
# coding: utf-8

import pytest

import hashlib
import numpy as np

from pymasq.datasets import load_census
from pymasq.mitigations import hashing


ALGORITHMS = hashlib.algorithms_guaranteed


def _my_df():
    df = load_census()
    cols = ["income_level", "age", "education", "race", "sex", "hours_per_week"]
    df = df.loc[:10, cols]
    return df


@pytest.fixture
def my_df():
    return _my_df()


@pytest.fixture
def salts():
    df = _my_df()
    return np.random.Generator.choice(["a", "b", "c"], size=df.shape).tolist()


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_all_hashlib_guaranteed_algorithms(my_df, hash_func):
    """
    Test all hashing algorithms that are guaranteed to be supported by hashlib, regardless of OS platform.
    """
    rdf = None
    try:
        rdf = hashing(my_df, hash_func)
    except Exception as e:
        print(f"Raised Exception: {e}")
    assert rdf is not None


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_changes_all_values(my_df, hash_func):
    """
    Test that hashing changes all the values from the original dataframe into their hashed counterpart
    """
    rdf = hashing(my_df, hash_func)
    assert not rdf.equals(my_df)


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_returns_same_dimensions(my_df, hash_func):
    """
    Test that hashing returns the same dimensions from the input dataframe
    """
    init_shape = my_df.shape
    rdf = hashing(my_df, hash_func)
    assert init_shape == rdf.shape


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_appended_salt_changes_all_values(my_df, hash_func):
    """
    Test that appending a salt changes the value of all the hash functions
    """
    rdf = hashing(my_df, hash_func)
    sdf = hashing(my_df, hash_func, salt="salt")
    assert not rdf.equals(sdf)


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_prepended_salt_changes_all_values(my_df, hash_func):
    """
    Test that prepending a salt changes the value of all the hash functions
    """
    rdf = hashing(my_df, hash_func)
    sdf = hashing(my_df, hash_func, salt="salt", append_salt=False)
    assert not rdf.equals(sdf)


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_appended_vs_prepended_salt_changes_all_values(my_df, hash_func):
    """
    Test that appended salts and prepended salts yield different values
    """
    rdf = hashing(my_df, hash_func, salt="salt", append_salt=True)  # deafult
    sdf = hashing(my_df, hash_func, salt="salt", append_salt=False)
    assert not rdf.equals(sdf)


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_different_salt_changes_all_values(my_df, hash_func):
    """
    Test that different salt values change the values differently
    """
    sdf1 = hashing(my_df, hash_func, salt="salt1")
    sdf2 = hashing(my_df, hash_func, salt="salt2")
    assert not sdf1.equals(sdf2)


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_os_generated_salt(my_df, hash_func):
    """
    Test that salts can be randomly generated by OS and yield different values
    """
    sdf1 = hashing(my_df, hash_func, salt=8)
    sdf2 = hashing(my_df, hash_func, salt=16)
    assert not sdf1.equals(sdf2)


@pytest.mark.parametrize("hash_func", (ALGORITHMS))
def test_hashing_hardcoded_salt(my_df, salts, hash_func):
    """
    Test that salts can be passed in by user and yield different values
    """
    sdf = hashing(my_df, hash_func, salt=salts)
    assert not sdf.equals(my_df)
